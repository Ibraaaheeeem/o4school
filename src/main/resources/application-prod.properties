# Production logging configuration
logging.config=classpath:logback-spring.xml

# Disable debug logging in production
logging.level.com.haneef._school=INFO
logging.level.org.springframework.security=WARN
logging.level.org.springframework.web=INFO
logging.level.org.hibernate.SQL=WARN

# JSON logging pattern (fallback if logback-spring.xml is not used)
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# Actuator Configuration - Secure for Production
# Only expose health and info endpoints
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=never
management.endpoint.info.enabled=true
management.info.env.enabled=false
management.info.java.enabled=false
management.info.os.enabled=false

# --- Performance Tuning ---

# 1. Enable Template Caching (Critical for CPU/Memory)
spring.thymeleaf.cache=true

# 2. Tomcat Tuning (High Memory / Low CPU)
# We have plenty of RAM (20GB), so we can handle more threads, 
# but we are limited by 1 vCPU, so too many threads will cause context switching.
server.tomcat.threads.max=200
server.tomcat.threads.min-spare=20

# 3. Disable DevTools in production
spring.devtools.restart.enabled=false
spring.devtools.livereload.enabled=false

# 4. JPA/Hibernate Optimizations
spring.jpa.open-in-view=false
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true

# 5. Native Image & Resource Optimizations
# Lazy init is still good for startup time on 1 vCPU
spring.main.lazy-initialization=true
# HikariCP: With 20GB RAM we can have a larger pool, but 1 vCPU limits throughput.
# 20 connections is a safe upper bound to avoid CPU thrashing.
spring.datasource.hikari.maximum-pool-size=20

